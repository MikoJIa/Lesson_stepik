# Обьём прямоугольного параллепипета


def get_V(a, b, c, verbose=True):  # есть ещё формальные параметры Например: verbose=True, но мы можем этот параметр
                                   # поменять на False прямо в вызове функции
    if verbose:                    # а вот a, b, c - это фактические параметры
        print(f'a - {a}, b - {b}, c - {c}')

    return a * b * c


res = get_V(1, 2, 3, False)  # здесь используется позиционная запись значения
# но можно присвоить параметрам любые значения в независимости от их расположения
res = get_V(b=1, a=2, c=3)  # такие аргументы называются именованными
# а можно ещё вот так
res = get_V(1, c=2, b=3)  # Вот только есть одно правило: сначала мы записываем позиционные аргументы, а только потом
# именованные
print(res)

# Ещё один пример с формальными параметрами. Предположим, нам надо написать функцию, которая сравнивает две строки между
# собой, но она могла бы сравнивать строки с учётом регистра или без, а так же учитывать пробелы до или после слова.


def cmp_str(s1, s2, reg=False, trim=True):
    if reg:  # если reg у нас True
        s1 = s1.lower()
        s2 = s2.lower()
    if trim:
        s1 = s1.strip()  # удаляет все пробелы и переносы строк
        s2 = s2.strip()

    return s1 == s2


print(cmp_str('Python ', ' Python'))  # True
print(cmp_str('Python ', ' PYTHON'))  # False
print(cmp_str('Python ', ' PYTHON', reg=True))  # То у нас проходит сравнение без учёта регистра

# Нюансы объявления функции с формальными параметрами

def add_value(value, lst=None):  # лучше всего формальные параметры назначать неизменяемыми типами
    if lst is None:
        lst = []
    lst.append(value)
    return lst


l = add_value(1)
l = add_value(2, l)
print(l)  # [1, 2]